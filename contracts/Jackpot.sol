// SPDX-License-Identifier: MIT

pragma solidity ^0.8.16;

/**
 * @title Jackpot
 * @dev A contract that allows for the creation of a jackpot.
 */

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

import "./JackpotComptroller.sol";

contract Jackpot is
    JackpotComptroller
{
    struct RandomResult {
        uint256 randomNumber; // random number generated by chainlink.
        uint256 nomalizedRandomNumber; // random number % size of the entries array. So between 0 and entries.length -1
    }

    // event sent when the random number is generated by the VRF
    event RandomNumberCreated(
        uint256 indexed idFromMetawin,
        uint256 randomNumber,
        uint256 normalizedRandomNumber
    );

    struct RaffleInfo {
        uint256 id; // raffleId
        uint256 size; // length of the entries array of that raffle
    }

    mapping(uint256 => RandomResult) public requests;
    // map the requestId created by chainlink with the raffle info passed as param when calling getRandomNumber()
    mapping(bytes32 => RaffleInfo) public chainlinkRaffleInfo;

    constructor(
          address _coordinator
        , address _linkToken
        , bytes32 _keyHash
        , uint256 _fee
    ) 
        JackpotComptroller(
              _coordinator
            , _linkToken
            , _keyHash
            , _fee
        )
    {

        

    }

    
    /// @param _desiredFundsInWeis the amount the seller would like to get from the raffle
    /// @param _maxEntriesPerUser To avoid whales, the number of entries an user can have is limited
    /// @param _collateralAddress The address of the NFT of the raffle
    /// @param _collateralId The id of the NFT (ERC721)
    /// @param _minimumFundsInWeis The mininum amount required for the raffle to set a winner
    /// @notice Creates a raffle
    /// @dev creates a raffle struct and push it to the raffles array. Some data is stored in the funding data structure
    /// sends an event when finished
    /// @return raffleId
    function createRaffle(
        uint256 _desiredFundsInWeis,
        uint256 _maxEntriesPerUser,
        address _collateralAddress,
        uint256 _collateralId,
        uint256 _minimumFundsInWeis,
        PriceStructure[] calldata _prices,
        uint256 _commissionInBasicPoints,
        address _requiredNFT
    ) external onlyRole(OPERATOR_ROLE) returns (uint256) {
        _createJackpot(
            _desiredFundsInWeis,
            _maxEntriesPerUser,
            _collateralAddress,
            _collateralId,
            _minimumFundsInWeis,
            _prices,
            _commissionInBasicPoints,
            _requiredNFT
        );
    }
}