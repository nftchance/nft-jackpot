/**
 * This is a real contract that was launched by metawin.com/xyz. Not only does it have multiple exploits, but it was argued that they were not exploits and they chose to launch with an immutable, yet fucked up contract. This repository is a journey into a better permissionless and trustless lottery.

 I highly advise noting the very bad code and practices in this contract and moving on :)
 */

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

// Interface to Chainlink VRF v1
//import "./IVRFConsumerv1.sol";

/// @title Raffles manager
/// @author Luis
/// @notice It consumes VRF v1 from Chainlink. It has the role
/// "operator" that is the one used by a backend app to make some calls
contract Manager is AccessControl, ReentrancyGuard, VRFConsumerBase {
    
    ////////// CHAINLINK VRF v1 /////////////////
    bytes32 internal keyHash; // chainlink
    uint256 internal fee; // fee paid in LINK to chainlink. 0.1 in Rinkeby, 2 in mainnet  

    struct RandomResult {
        uint256 randomNumber; // random number generated by chainlink.
        uint256 nomalizedRandomNumber; // random number % size of the entries array. So between 0 and entries.length -1
    }

    // event sent when the random number is generated by the VRF
    event RandomNumberCreated(
        uint256 indexed idFromMetawin,
        uint256 randomNumber,
        uint256 normalizedRandomNumber
    );

    struct RaffleInfo {
        uint256 id; // raffleId
        uint256 size; // length of the entries array of that raffle
    }

    mapping(uint256 => RandomResult) public requests;
    // map the requestId created by chainlink with the raffle info passed as param when calling getRandomNumber()
    mapping(bytes32 => RaffleInfo) public chainlinkRaffleInfo;

    /////////////// END CHAINKINK VRF V1 //////////////

    // Event sent when the raffle is created by the operator
    event RaffleCreated(
        uint256 indexed raffleId,
        address indexed nftAddress,
        uint256 indexed nftId
    );
    // Event sent when the owner of the nft stakes it for the raffle
    event RaffleStarted(uint256 indexed raffleId, address indexed seller);
    // Event sent when the raffle is finished (either early cashout or successful completion)
    event RaffleEnded(
        uint256 indexed raffleId,
        address indexed winner,
        uint256 amountRaised,
        uint256 randomNumber
    );
    // Event sent when one or more entries are sold (info from the price structure)
    event EntrySold(
        uint256 indexed raffleId,
        address indexed buyer,
        uint256 currentSize,
        uint256 priceStructureId
    );
    // Event sent when a free entry is added by the operator
    event FreeEntry(
        uint256 indexed raffleId,
        address[] buyer,
        uint256 amount,
        uint256 currentSize
    );
    // Event sent when a raffle is asked to cancel by the operator
    event RaffleCancelled(uint256 indexed raffleId, uint256 amountRaised);
    // The raffle is closed successfully and the platform receives the fee
    event FeeTransferredToPlatform(
        uint256 indexed raffleId,
        uint256 amountTransferred
    );
    // When the raffle is asked to be cancelled and 30 days have passed, the operator can call a method
    // to transfer the remaining funds and this event is emitted
    event RemainingFundsTransferred(
        uint256 indexed raffleId,
        uint256 amountInWeis
    );
    // When the raffle is asked to be cancelled and 30 days have not passed yet, the players can call a
    // method to refund the amount spent on the raffle and this event is emitted
    event Refund(
        uint256 indexed raffleId,
        uint256 amountInWeis,
        address indexed player
    );
    event EarlyCashoutTriggered(uint256 indexed raffleId, uint256 amountRaised);
    event SetWinnerTriggered(uint256 indexed raffleId, uint256 amountRaised);
    event StatusChangedInEmergency(uint256 indexed raffleId, uint256 newStatus);

    /* every raffle has an array of price structure (max size = 5) with the different 
    prices for the different entries bought. The price for 1 entry is different than 
    for 5 entries where there is a discount*/
    struct PriceStructure {
        uint256 id;
        uint256 numEntries;
        uint256 price;
    }
    mapping(uint256 => PriceStructure[5]) public prices;

    // Every raffle has a funding structure.
    struct FundingStructure {
        uint256 minimumFundsInWeis;
        uint256 desiredFundsInWeis;
    }
    mapping(uint256 => FundingStructure) public fundingList;

    // Main raffle data struct
    struct RaffleStruct {
        STATUS status; // status of the raffle. Can be created, accepted, ended, etc
        uint256 maxEntries; // maximum number of entries allowed per user, to avoid abuse
        address collateralAddress; // address of the NFT
        uint256 collateralId; // NFT id of the NFT
        address winner; // address of thed winner of the raffle. Address(0) if no winner yet
        uint256 randomNumber; // normalized (0-Entries array size) random number generated by the VRF
        uint256 amountRaised; // funds raised so far in wei
        address[] entries; // array of addresses of the entries bought
        address seller; // address of the seller of the NFT
        uint256 platformPercentage; // percentage of the funds raised that goes to the platform
        address requiredNFT; // address of the required nft. Will be address(0) if no NFT is required to buy
        uint256 entriesLength; // to easy frontend, the length of the entries array is saved here
        uint256 cancellingDate;
    }
    // The main structure is an array of raffles
    RaffleStruct[] public raffles;

    // Map that contains the number of entries each user has bought, to prevent abuse, and the claiming info
    struct ClaimStruct {
        uint256 numEntriesPerUser;
        uint256 amountSpentInWeis;
        bool claimed;
    }
    mapping(bytes32 => ClaimStruct) public claimsData;

    // All the different status a raffle can have
    enum STATUS {
        CREATED, // the operator creates the raffle
        ACCEPTED, // the seller stakes the nft for the raffle
        EARLY_CASHOUT, // the seller wants to cashout early
        CANCELLED, // the operator cancels the raffle and transfer the remaining funds after 30 days passes
        CLOSING_REQUESTED, // the operator sets a winner
        ENDED, // the raffle is finished, and NFT and funds were transferred
        CANCEL_REQUESTED // operator asks to cancel the raffle. Players has 30 days to ask for a refund
    }
    // The operator role is operated by a backend application
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR");

    // address of the wallet controlled by the platform that will receive the platform fee
    address payable public destinationWallet =
        payable(0x12334d915d254F1FFD3f7ea80bB5Eba5eA87Fb36);

    // address of the VRF v1 Consumer contract from Chainlink
    //   address public chainlinkContractAddress;

    constructor()
        VRFConsumerBase(
            0xf0d54349aDdcf704F77AE15b96510dEA15cb7952, // VRF Coordinator
            0x514910771AF9Ca656af840dff83E8264EcF986CA // LINK Token
        )
    {
        //chainlinkContractAddress = _VRFAddress;
        _setupRole(OPERATOR_ROLE, msg.sender);
        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);

        keyHash = 0xAA77729D3466CA35AE8D28B3BBAC7CC36A5031EFDC430821C02BC31A238AF445;
        // fee = 0.1 * 10**18; // 0.1 LINK In Rinkeby
        // in mainnet, the fee must be 2 LINK
        fee = 2 * 10**18;
    }

    /// @dev this is the method that will be called by the smart contract to get a random number
    /// @param _id Id of the raffle
    /// @param _entriesSize length of the entries array of that raffle
    /// @return requestId Id generated by chainlink
    function getRandomNumber(uint256 _id, uint256 _entriesSize)
        internal
        returns (bytes32 requestId)
    {
        require(
            LINK.balanceOf(address(this)) > fee,
            "Not enough LINK - fill contract with faucet"
        );
        bytes32 result = requestRandomness(keyHash, fee);
        // result is the requestId generated by chainlink. It is saved in a map linked to the param id
        chainlinkRaffleInfo[result] = RaffleInfo({id: _id, size: _entriesSize});
        return result;
    }

    /// @dev Callback function used by VRF Coordinator. Is called by chainlink
    /// the random number generated is normalized to the size of the entries array, and an event is
    /// generated, that will be listened by the platform backend to be checked if corresponds to a
    /// member of the MW community, and if true will call transferNFTAndFunds
    /// @param requestId id generated previously (on method getRandomNumber by chainlink)
    /// @param randomness random number (huge) generated by chainlink
    function fulfillRandomness(bytes32 requestId, uint256 randomness)
        internal
        override
    {
        // randomness is the actual random number. Now extract from the aux map the original param id of the call
        RaffleInfo memory raffleInfo = chainlinkRaffleInfo[requestId];
        // save the random number on the map with the original id as key
        uint256 normalizedRandomNumber = randomness % raffleInfo.size;

        RandomResult memory result = RandomResult({
            randomNumber: randomness,
            nomalizedRandomNumber: normalizedRandomNumber
        });

        requests[raffleInfo.id] = result;

        // send the event with the original id and the random number
        emit RandomNumberCreated(
            raffleInfo.id,
            randomness,
            normalizedRandomNumber
        );

        transferNFTAndFunds(raffleInfo.id, normalizedRandomNumber);
    }

    //////////////////////////////////////////////



    /*
    Callable only by the owner of the NFT
    Once the operator has created the raffle, he can stake the NFT
    At this moment, the NFT is locked and the players can buy entries
    */
    /// @param _raffleId Id of the raffle
    /// @notice The owner of the NFT can stake it on the raffle. At this moment the raffle starts and can sell entries to players
    /// @dev the owner must have approved this contract before. Otherwise will revert when transferring from the owner
    function stakeNFT(uint256 _raffleId) external {
        RaffleStruct storage raffle = raffles[_raffleId];
        // Check if the raffle is already created
        require(raffle.status == STATUS.CREATED, "Raffle not CREATED");
        // the owner of the NFT must be the current caller
        IERC721 token = IERC721(raffle.collateralAddress);
        require(
            token.ownerOf(raffle.collateralId) == msg.sender,
            "NFT is not owned by caller"
        );

        raffle.status = STATUS.ACCEPTED;
        raffle.seller = msg.sender;

        // transfer the asset to the contract
        //  IERC721 _asset = IERC721(raffle.collateralAddress);
        token.transferFrom(msg.sender, address(this), raffle.collateralId); // transfer the token to the contract

        emit RaffleStarted(_raffleId, msg.sender);
    }

    /// @dev callable by players. Depending on the number of entries assigned to the price structure the player buys (_id parameter)
    /// one or more entries will be assigned to the player.
    /// Also it is checked the maximum number of entries per user is not reached
    /// As the method is payable, in msg.value there will be the amount paid by the user
    /// @notice If the operator made a call to set a required nft, only the owners of that nft can make a call to this method. This will be
    /// used for special raffles
    /// @param _raffleId: id of the raffle
    /// @param _id: id of the price structure
    function buyEntry(uint256 _raffleId, uint256 _id)
        external
        payable
        nonReentrant
    {
        if (raffles[_raffleId].requiredNFT != address(0)) {
            IERC721 requiredNFT = IERC721(raffles[_raffleId].requiredNFT);
            require(requiredNFT.balanceOf(msg.sender) > 0, "No NFT");
        }
        require(msg.sender != address(0), "msg.sender is null"); // 37
        require(_id > 0, "howMany is 0");
        require(
            raffles[_raffleId].status == STATUS.ACCEPTED,
            "Raffle is not in accepted"
        ); // 1808
        PriceStructure memory priceStruct = getPriceStructForId(_raffleId, _id);
        //  require(priceStruct.price > 0, "id not supported");
        require(
            msg.value == priceStruct.price,
            "msg.value must be equal to the price"
        ); // 1722

        bytes32 hash = keccak256(abi.encode(msg.sender, _raffleId));
        // check there are enough entries left for this particular user
        require(
            claimsData[hash].numEntriesPerUser + priceStruct.numEntries <=
                raffles[_raffleId].maxEntries,
            "Bought too many entries"
        ); // 3425

        address entry = msg.sender; // 12
        for (uint256 i = 0; i < priceStruct.numEntries; i++) {
            raffles[_raffleId].entries.push(entry);
        }
        raffles[_raffleId].amountRaised += msg.value; // 6917 gas
        // update the field entriesLength, used in frontend to avoid making extra calls
        raffles[_raffleId].entriesLength = raffles[_raffleId].entries.length;
        //update claim data
        claimsData[hash].numEntriesPerUser += priceStruct.numEntries;
        claimsData[hash].amountSpentInWeis += msg.value;

        emit EntrySold(
            _raffleId,
            msg.sender,
            raffles[_raffleId].entries.length,
            _id
        ); // 2377
    }

    // The operator can add free entries to the raffle
    /// @param _raffleId Id of the raffle
    /// @param _freePlayers array of addresses corresponding to the wallet of the users that won a free entrie
    /// @dev only operator can make this call. Assigns a single entry per user, except if that user already reached the max limit of entries per user
    function giveBatchEntriesForFree(
        uint256 _raffleId,
        address[] memory _freePlayers
    ) external payable nonReentrant onlyRole(OPERATOR_ROLE) {
        require(
            raffles[_raffleId].status == STATUS.ACCEPTED,
            "Raffle is not in accepted"
        );

        uint256 freePlayersLength = _freePlayers.length;
        for (uint256 i = 0; i < freePlayersLength; i++) {
            address entry = _freePlayers[i];
            if (
                claimsData[keccak256(abi.encode(entry, _raffleId))]
                    .numEntriesPerUser +
                    1 <=
                raffles[_raffleId].maxEntries
            ) {
                raffles[_raffleId].entries.push(entry);
                claimsData[keccak256(abi.encode(entry, _raffleId))]
                    .numEntriesPerUser++;
            }
        }

        raffles[_raffleId].entriesLength = raffles[_raffleId].entries.length;

        emit FreeEntry(
            _raffleId,
            _freePlayers,
            freePlayersLength,
            raffles[_raffleId].entries.length
        );
    }

    // The operator can call this method once they receive the event "RandomNumberCreated"
    // triggered by the VRF v1 consumer contract (RandomNumber.sol)
    /// @param _raffleId Id of the raffle
    /// @param _normalizedRandomNumber index of the array that contains the winner of the raffle. Generated by chainlink
    /// @notice it is the method that sets the winner and transfers funds and nft
    /// @dev called only after the backekd checks the winner is a member of MW. Only those who bought using the MW site
    /// can be winners, not those who made the call to "buyEntries" directly without using MW
    function transferNFTAndFunds(
        uint256 _raffleId,
        uint256 _normalizedRandomNumber
    ) internal nonReentrant {
        RaffleStruct storage raffle = raffles[_raffleId];
        // Only when the raffle has been asked to be closed and the platform
        require(
            raffle.status == STATUS.EARLY_CASHOUT ||
                raffle.status == STATUS.CLOSING_REQUESTED,
            "Raffle in wrong status"
        );

        raffle.randomNumber = _normalizedRandomNumber;
        raffle.winner = raffle.entries[_normalizedRandomNumber];
        raffle.status = STATUS.ENDED;

        IERC721 _asset = IERC721(raffle.collateralAddress);
        _asset.transferFrom(
            address(this),
            raffle.entries[_normalizedRandomNumber],
            raffle.collateralId
        ); // transfer the tokens to the contract

        uint256 amountForPlatform = (raffle.amountRaised *
            raffle.platformPercentage) / 10000;
        uint256 amountForSeller = raffle.amountRaised - amountForPlatform;
        // transfer amount (75%) to the seller.
        (bool sent, ) = raffle.seller.call{value: amountForSeller}("");
        require(sent, "Failed to send Ether");
        // transfer the amount to the platform
        (bool sent2, ) = destinationWallet.call{value: amountForPlatform}("");
        require(sent2, "Failed send Eth to MW");
        emit FeeTransferredToPlatform(_raffleId, amountForPlatform);

        emit RaffleEnded(
            _raffleId,
            raffle.entries[_normalizedRandomNumber],
            raffle.amountRaised,
            _normalizedRandomNumber
        );
    }





}
